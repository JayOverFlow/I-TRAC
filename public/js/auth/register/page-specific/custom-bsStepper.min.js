document.addEventListener('DOMContentLoaded', function () {

    // Modern Alert System
    function showModernAlert(message, type = 'success', duration = 4000) {
        // Remove any existing alerts
        const existingAlerts = document.querySelectorAll('.modern-alert');
        existingAlerts.forEach(alert => alert.remove());
        
        // Create alert element
        const alert = document.createElement('div');
        alert.className = `modern-alert ${type}`;
        
        // Choose icon based on type
        const iconSvg = type === 'success' 
            ? '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg>'
            : '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line></svg>';
        
        alert.innerHTML = `
            <div class="modern-alert-icon">${iconSvg}</div>
            <div class="modern-alert-content">${message}</div>
            <button class="modern-alert-close">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
            </button>
        `;
        
        // Add to DOM
        document.body.appendChild(alert);
        
        // Add close functionality
        const closeBtn = alert.querySelector('.modern-alert-close');
        closeBtn.addEventListener('click', () => {
            hideAlert(alert);
        });
        
        // Show alert with animation
        setTimeout(() => {
            alert.classList.add('show');
        }, 100);
        
        // Auto-hide after duration
        if (duration > 0) {
            setTimeout(() => {
                hideAlert(alert);
            }, duration);
        }
        
        return alert;
    }
    
    function hideAlert(alert) {
        if (!alert) return;
        
        alert.classList.remove('show');
        setTimeout(() => {
            if (alert.parentNode) {
                alert.parentNode.removeChild(alert);
            }
        }, 300);
    }

    /**
     * 
     *  Validation Horizontal  
     * 
     */

    var formValidation = document.querySelector('.stepper-form-validation-one');
    
    // Only initialize if the element exists
    if (formValidation) {
        var stepper = new Stepper(formValidation, {
            animation: true
        })
        var formValidationNextButton = formValidation.querySelectorAll('.btn-nxt');
        var formValidationBackButton = formValidation.querySelectorAll('.btn-back');
        var formValidationSubmit = formValidation.querySelector('.btn-submit');
        var stepperPanList = [].slice.call(formValidation.querySelectorAll('.content'))
        
        // Fix the selectors to match your HTML
        // var inputName = formValidation.querySelector('#validationStepform-first-name');
        var formEl = formValidation.querySelector('.bs-stepper-content form')

        function toggleLabelFeedback(inputEl, shouldShow) {
            if (!inputEl) return;
            const labelRow = inputEl.previousElementSibling;
            if (!labelRow) return;
            const feedbackEl = labelRow.querySelector('.invalid-feedback');
            if (!feedbackEl) return;
            feedbackEl.classList.toggle('d-block', shouldShow);
        }

        function setLabelFeedbackMessage(inputEl, message) {
            if (!inputEl) return;
            const labelRow = inputEl.previousElementSibling;
            if (!labelRow) return;
            const feedbackEl = labelRow.querySelector('.invalid-feedback');
            if (!feedbackEl) return;
            if (typeof message === 'string') {
                feedbackEl.textContent = message;
            }
        }

        function setFieldValid(inputEl) {
            if (!inputEl) return;
            inputEl.classList.remove('is-invalid');
            inputEl.classList.add('is-valid');
            toggleLabelFeedback(inputEl, false);
        }

        function setFieldInvalid(inputEl, message) {
            if (!inputEl) return;
            inputEl.classList.remove('is-valid');
            inputEl.classList.add('is-invalid');
            setLabelFeedbackMessage(inputEl, message);
            toggleLabelFeedback(inputEl, true);
        }

        function toggleFeedbackInContainer(containerEl, shouldShow) {
            if (!containerEl) return;
            const feedbackEl = containerEl.querySelector('.invalid-feedback');
            if (!feedbackEl) return;
            feedbackEl.classList.toggle('d-block', shouldShow);
        }

        // function validateStepOne() {
        //     // Get all the input fields
        //     const currentStep = document.querySelector('#validationStep-one');
        //     const firstName = document.querySelector('#first-name');
        //     const middleName = document.querySelector('#middle-name');
        //     const lastName = document.querySelector('#last-name');
        //     const suffix = document.querySelector('#suffix');
        //     const tupID = document.querySelector('#tup-id');

        //     const stepOneValidation = {
        //         firstName: {
        //             el: firstName,
        //             required: true,
        //             min: 3,
        //             max: 50,
        //             messages: {
        //                 required: 'First name is required.',
        //                 min: 'First name must be at least 3 characters.',
        //                 max: 'First name must be 50 characters or less.',
        //             }
        //         },
        //         middleName: {
        //             el: middleName,
        //             required: true,
        //             min: 3,
        //             max: 50,
        //             messages: {
        //                 required: 'Middle name is required.',
        //                 min: 'Middle name must be at least 3 characters.',
        //                 max: 'Middle name must be 50 characters or less.',
        //             }
        //         },
        //         lastName: {
        //             el: lastName,
        //             required: true,
        //             min: 3,
        //             max: 50,
        //             messages: {
        //                 required: 'Last name is required.',
        //                 min: 'Last name must be at least 3 characters.',
        //                 max: 'Last name must be 50 characters or less.',
        //             }
        //         },
        //         suffix: {
        //             el: suffix,
        //             required: false,
        //             max: 10,
        //             messages: {
        //                 max: 'Suffix must be 10 characters or less.',
        //             }
        //         },
        //         tupID: {
        //             el: tupID,
        //             required: true,
        //             pattern: /^\d{6}$/,
        //             messages: {
        //                 required: 'TUP ID is required.',
        //                 pattern: 'TUP ID must be exactly 6 digits.'
        //             }
        //         }
        //     };

        //     let isValid = true;

        //     // Clear validation states
        //     currentStep.querySelectorAll('.form-control').forEach(input => {
        //         input.classList.remove('is-invalid', 'is-valid');
        //         toggleLabelFeedback(input, false);
        //     });

        //     Object.values(stepOneValidation).forEach(cfg => {
        //         const el = cfg.el;
        //         if (!el) {
        //             isValid = false;
        //             return;
        //         }

        //         const value = (el.value || '').trim();

        //         if (!cfg.required && value.length === 0) {
        //             setFieldValid(el);
        //             return;
        //         }

        //         if (cfg.required && value.length === 0) {
        //             setFieldInvalid(el, cfg.messages.required);
        //             isValid = false;
        //             return;
        //         }

        //         if (typeof cfg.min === 'number' && value.length < cfg.min) {
        //             setFieldInvalid(el, cfg.messages.min);
        //             isValid = false;
        //             return;
        //         }

        //         if (typeof cfg.max === 'number' && value.length > cfg.max) {
        //             setFieldInvalid(el, cfg.messages.max);
        //             isValid = false;
        //             return;
        //         }

        //         if (cfg.pattern instanceof RegExp && !cfg.pattern.test(value)) {
        //             setFieldInvalid(el, cfg.messages.pattern);
        //             isValid = false;
        //             return;
        //         }

        //         setFieldValid(el);
        //     });

        //     return isValid;
        // }

        function validateStepOne() {
            // Get all the input fields
            const currentStep = document.querySelector('#validationStep-one');
            const firstName = document.querySelector('#first-name');
            const middleName = document.querySelector('#middle-name');
            const lastName = document.querySelector('#last-name');
            const suffix = document.querySelector('#suffix');
            const tupID = document.querySelector('#tup-id');

            const stepOneValidation = {
                firstName: {
                    el: firstName,
                    required: true,
                    min: 3,
                    max: 50,
                    messages: {
                        required: 'First name is required.',
                        min: 'First name must be at least 3 characters.',
                        max: 'First name must be 50 characters or less.',
                    }
                },
                middleName: {
                    el: middleName,
                    required: true,
                    min: 3,
                    max: 50,
                    messages: {
                        required: 'Middle name is required.',
                        min: 'Middle name must be at least 3 characters.',
                        max: 'Middle name must be 50 characters or less.',
                    }
                },
                lastName: {
                    el: lastName,
                    required: true,
                    min: 3,
                    max: 50,
                    messages: {
                        required: 'Last name is required.',
                        min: 'Last name must be at least 3 characters.',
                        max: 'Last name must be 50 characters or less.',
                    }
                },
                suffix: {
                    el: suffix,
                    required: false,
                    max: 10,
                    messages: {
                        max: 'Suffix must be 10 characters or less.',
                    }
                },
                tupID: {
                    el: tupID,
                    required: true,
                    pattern: /^\d{6}$/,
                    messages: {
                        required: 'TUP ID is required.',
                        pattern: 'TUP ID must be exactly 6 digits.'
                    }
                }
            };

            let isValid = true;

            // Clear validation states
            currentStep.querySelectorAll('.form-control').forEach(input => {
                input.classList.remove('is-invalid', 'is-valid');
                toggleLabelFeedback(input, false);
            });

            // Frontend validation
            Object.values(stepOneValidation).forEach(cfg => {
                const el = cfg.el;
                if (!el) {
                    isValid = false;
                    return;
                }

                const value = (el.value || '').trim();

                if (!cfg.required && value.length === 0) {
                    setFieldValid(el);
                    return;
                }

                if (cfg.required && value.length === 0) {
                    setFieldInvalid(el, cfg.messages.required);
                    isValid = false;
                    return;
                }

                if (typeof cfg.min === 'number' && value.length < cfg.min) {
                    setFieldInvalid(el, cfg.messages.min);
                    isValid = false;
                    return;
                }

                if (typeof cfg.max === 'number' && value.length > cfg.max) {
                    setFieldInvalid(el, cfg.messages.max);
                    isValid = false;
                    return;
                }

                if (cfg.pattern instanceof RegExp && !cfg.pattern.test(value)) {
                    setFieldInvalid(el, cfg.messages.pattern);
                    isValid = false;
                    return;
                }

                setFieldValid(el);
            });

            // If frontend validation passes, call backend validation
            if (isValid) {
                const data = {
                    validate_and_store: true,
                    step: 1,
                    first_name: firstName.value,
                    middle_name: middleName.value,
                    last_name: lastName.value,
                    suffix: suffix.value,
                    tup_id: tupID.value
                };
                
                fetch('/register', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRF-TOKEN': document.querySelector('meta[name="csrf-token"]').getAttribute('content')
                    },
                    body: JSON.stringify(data)
                })
                .then(response => response.json())
                .then(result => {
                    if (result.success) {
                        stepper.next();
                    } else {
                        // Show backend validation errors in same place
                        if (result.errors) {
                            for (let field in result.errors) {
                                if (field === 'first_name') setFieldInvalid(firstName, result.errors[field][0]);
                                if (field === 'middle_name') setFieldInvalid(middleName, result.errors[field][0]);
                                if (field === 'last_name') setFieldInvalid(lastName, result.errors[field][0]);
                                if (field === 'suffix') setFieldInvalid(suffix, result.errors[field][0]);
                                if (field === 'tup_id') setFieldInvalid(tupID, result.errors[field][0]);
                            }
                        }
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                });
            }

            return false; // Prevent automatic stepper progression
        }

        function validateStepTwo() {
            // Get all the input fields
            const currentStep = document.querySelector('#validationStep-two');
            const email = document.querySelector('#email');
            const password = document.querySelector('#password');
            const confirmPassword = document.querySelector('#confirm-password');
            const userType = document.querySelector('input[name="user_type"]:checked');
            const userTypeContainer = currentStep?.querySelector('.col-6'); // Radio button container
            const department = document.querySelector('#department');

            let isValid = true;

            // Clear validation states
            currentStep.querySelectorAll('.form-control').forEach(input => {
                input.classList.remove('is-invalid', 'is-valid');
                toggleLabelFeedback(input, false);
            });
            
            // Clear user type validation state
            if (userTypeContainer) {
                userTypeContainer.classList.remove('is-invalid', 'is-valid');
                const userTypeFeedback = userTypeContainer.querySelector('.invalid-feedback');
                if (userTypeFeedback) {
                    userTypeFeedback.classList.remove('d-block');
                    userTypeFeedback.textContent = '';
                }
            }

            // Frontend validation
            const stepTwoValidation = {
                email: {
                    el: email,
                    required: true,
                    pattern: /^.+@tup\.edu\.ph$/i,
                    messages: {
                        required: 'Email is required.',
                        pattern: 'Email must be a valid @tup.edu.ph address.'
                    }
                },
                password: {
                    el: password,
                    required: true,
                    min: 8,
                    messages: {
                        required: 'Password is required.',
                        min: 'Password must be at least 8 characters.'
                    }
                },
                confirmPassword: {
                    el: confirmPassword,
                    required: true,
                    messages: {
                        required: 'Please confirm password.',
                        custom: 'Passwords do not match.'
                    }
                },
                userType: {
                    el: userType,
                    container: userTypeContainer,
                    required: true,
                    messages: {
                        required: 'Please select a user type.'
                    }
                },
                department: {
                    el: department,
                    required: true,
                    messages: {
                        required: 'Select a department.'
                    }
                }
            };

            Object.values(stepTwoValidation).forEach(cfg => {
                const el = cfg.el;
                const container = cfg.container;
                
                // Handle user type validation (radio buttons)
                if (cfg.el === userType) {
                    if (!cfg.required) {
                        if (container) container.classList.add('is-valid');
                        return;
                    }

                    if (!el) {
                        if (container) {
                            container.classList.add('is-invalid');
                            container.classList.remove('is-valid');
                            const feedback = container.querySelector('.invalid-feedback');
                            if (feedback) {
                                feedback.textContent = cfg.messages.required;
                                feedback.classList.add('d-block');
                            }
                        }
                        isValid = false;
                        return;
                    }

                    if (container) {
                        container.classList.add('is-valid');
                        container.classList.remove('is-invalid');
                        const feedback = container.querySelector('.invalid-feedback');
                        if (feedback) {
                            feedback.classList.remove('d-block');
                        }
                    }
                    return;
                }

                // Handle other field validations
                if (!el) {
                    isValid = false;
                    return;
                }

                const value = (el.value || '').trim();

                if (!cfg.required && value.length === 0) {
                    setFieldValid(el);
                    return;
                }

                if (cfg.required && (value.length === 0 || value === '' || value === 'Select')) {
                    setFieldInvalid(el, cfg.messages.required);
                    isValid = false;
                    return;
                }

                if (typeof cfg.min === 'number' && value.length < cfg.min) {
                    setFieldInvalid(el, cfg.messages.min);
                    isValid = false;
                    return;
                }

                if (cfg.pattern instanceof RegExp && !cfg.pattern.test(value)) {
                    setFieldInvalid(el, cfg.messages.pattern);
                    isValid = false;
                    return;
                }

                // Custom validation for confirm password
                if (cfg.el === confirmPassword && confirmPassword.value !== password.value) {
                    setFieldInvalid(confirmPassword, cfg.messages.custom);
                    isValid = false;
                    return;
                }

                setFieldValid(el);
            });

            // If frontend validation passes, call backend validation
            if (isValid) {
                const data = {
                    validate_and_store: true,
                    step: 2,
                    email: email.value,
                    password: password.value,
                    confirm_password: confirmPassword.value,
                    user_type: userType ? userType.value : 'Staff',
                    department: department.value
                };
                
                fetch('/register', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRF-TOKEN': document.querySelector('meta[name="csrf-token"]').getAttribute('content')
                    },
                    body: JSON.stringify(data)
                })
                .then(response => response.json())
                .then(result => {
                    if (result.success) {
                        updateReviewStep();
                        stepper.next();
                    } else {
                        // Show backend validation errors in same place
                        if (result.errors) {
                            for (let field in result.errors) {
                                if (field === 'email') setFieldInvalid(email, result.errors[field][0]);
                                if (field === 'password') setFieldInvalid(password, result.errors[field][0]);
                                if (field === 'confirm_password') setFieldInvalid(confirmPassword, result.errors[field][0]);
                                if (field === 'user_type') {
                                    if (userTypeContainer) {
                                        userTypeContainer.classList.add('is-invalid');
                                        userTypeContainer.classList.remove('is-valid');
                                        const feedback = userTypeContainer.querySelector('.invalid-feedback');
                                        if (feedback) {
                                            feedback.textContent = result.errors[field][0];
                                            feedback.classList.add('d-block');
                                        }
                                    }
                                }
                                if (field === 'department') setFieldInvalid(department, result.errors[field][0]);
                            }
                        }
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                });
            }

            return false; // Prevent automatic stepper progression
        }

        // Resend Code Timer and Rate Limiting
        let resendAttempts = 0;
        let resendTimer = null;

        function startResendTimer(seconds) {
            const resendBtn = document.getElementById('resend-code-btn');
            const timerDisplay = document.getElementById('resend-timer');
            
            // Ensure button is disabled and styled correctly
            resendBtn.disabled = true;
            resendBtn.textContent = 'Resend';
            resendBtn.style.pointerEvents = 'none';
            resendBtn.style.opacity = '0.6';
            
            let remaining = seconds;
            
            // Clear any existing timer
            if (resendTimer) {
                clearInterval(resendTimer);
            }
            
            resendTimer = setInterval(() => {
                if (remaining <= 0) {
                    clearInterval(resendTimer);
                    resendBtn.disabled = false;
                    resendBtn.style.pointerEvents = 'auto';
                    resendBtn.style.opacity = '1';
                    timerDisplay.textContent = '';
                    return;
                }
                
                const minutes = Math.floor(remaining / 60);
                const secs = remaining % 60;
                const display = minutes > 0 ? `${minutes}:${secs.toString().padStart(2, '0')}` : `${secs}s`;
                
                timerDisplay.textContent = `(${display})`;
                remaining--;
            }, 1000);
        }

        // Handle Send Code button click (Step 3)
        document.querySelector('#send-code-btn').addEventListener('click', function() {
            const email = document.querySelector('#email').value;
            
            this.disabled = true;
            this.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-loader spin me-2"><line x1="12" y1="2" x2="12" y2="6"></line><line x1="12" y1="18" x2="12" y2="22"></line><line x1="4.93" y1="4.93" x2="7.76" y2="7.76"></line><line x1="16.24" y1="16.24" x2="19.07" y2="19.07"></line><line x1="2" y1="12" x2="6" y2="12"></line><line x1="18" y1="12" x2="22" y2="12"></line><line x1="4.93" y1="19.07" x2="7.76" y2="16.24"></line><line x1="16.24" y1="7.76" x2="19.07" y2="4.93"></line></svg>Sending...';
            
            fetch('/email/send-code', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRF-TOKEN': document.querySelector('meta[name="csrf-token"]').getAttribute('content')
                },
                body: JSON.stringify({ email: email })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Close modal immediately and forcefully
                    const modalElement = document.getElementById('exampleModalCenter');
                    const modal = bootstrap.Modal.getInstance(modalElement);
                    
                    if (modal) {
                        modal.hide();
                    } else {
                        // Fallback: Create new instance and hide
                        const newModal = new bootstrap.Modal(modalElement);
                        newModal.hide();
                    }
                    
                    // Force remove backdrop if it's stuck
                    setTimeout(() => {
                        const backdrop = document.querySelector('.modal-backdrop');
                        if (backdrop) {
                            backdrop.remove();
                        }
                        document.body.classList.remove('modal-open');
                        document.body.style.overflow = '';
                        document.body.style.paddingRight = '';
                    }, 100);
                    
                    // Move to step 4 after modal is closed
                    setTimeout(() => {
                        stepper.next();
                        // Start 60-second resend timer
                        resendAttempts = 1;
                        startResendTimer(60);
                        // Show success alert
                        showModernAlert('Verification code sent successfully!', 'success');
                    }, 200);
                } else {
                    showModernAlert(data.message, 'error');
                    this.disabled = false;
                    this.textContent = 'Send Code';
                }
            })
            .catch(error => {
                console.error('Error:', error);
                showModernAlert('Error sending verification code. Please try again.', 'error');
                this.disabled = false;
                this.textContent = 'Send Code';
            });
        });

        // Handle Resend Code button click (Step 4)
        document.getElementById('resend-code-btn').addEventListener('click', function() {
            const email = document.querySelector('#email').value;
            
            this.disabled = true;
            this.textContent = 'Sending...';
            
            fetch('/email/send-code', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRF-TOKEN': document.querySelector('meta[name="csrf-token"]').getAttribute('content')
                },
                body: JSON.stringify({ email: email })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showModernAlert('New verification code sent successfully!', 'success');
                    
                    // Clear OTP inputs and focus first
                    document.querySelectorAll('.opt-input').forEach(input => input.value = '');
                    document.querySelectorAll('.opt-input')[0].focus();
                    
                    // Exponential backoff: 1st retry = 60s, 2nd+ retry = 5min
                    resendAttempts++;
                    const cooldownTime = resendAttempts >= 3 ? 300 : 60;
                    startResendTimer(cooldownTime);
                } else {
                    showModernAlert(data.message, 'error');
                    this.disabled = false;
                    this.textContent = 'Resend';
                }
            })
            .catch(error => {
                console.error('Error:', error);
                showModernAlert('Error sending verification code. Please try again.', 'error');
                this.disabled = false;
                this.textContent = 'Resend';
            });
        });

   // Collect user inputs for review (step 3)
        function collectFormData() {
            return {
                firstName: document.querySelector('#first-name').value,
                middleName: document.querySelector('#middle-name').value,
                lastName: document.querySelector('#last-name').value,
                suffix: document.querySelector('#suffix').value || 'N/A',
                tupID: document.querySelector('#tup-id').value,
                email: document.querySelector('#email').value,
                password: '••••••••', // Masked for security
                userType: document.querySelector('input[name="user_type"]:checked')?.nextElementSibling?.textContent?.trim(),
                department: document.querySelector('#department').options[document.querySelector('#department').selectedIndex]?.text
            };
        }

        function updateReviewStep() {
            const data = collectFormData();
            
            // Update left column
            document.querySelector('#review-first-name').textContent = data.firstName;
            document.querySelector('#review-last-name').textContent = data.lastName;
            document.querySelector('#review-email').textContent = data.email;
            document.querySelector('#review-password').textContent = data.password;
            
            // Update right column  
            document.querySelector('#review-middle-name').textContent = data.middleName;
            document.querySelector('#review-suffix').textContent = data.suffix;
            document.querySelector('#review-tup-id').textContent = data.tupID;
            document.querySelector('#review-user-type').textContent = data.userType;
            
            // Update department row
            document.querySelector('#review-department').textContent = data.department;
            
            // Setup password toggle
            setupPasswordToggle();
        }

        function setupPasswordToggle() {
            const toggleBtn = document.getElementById('toggle-password-review');
            const toggleIcon = document.getElementById('password-toggle-icon');
            const passwordDisplay = document.getElementById('review-password');
            
            if (!toggleBtn || !toggleIcon || !passwordDisplay) {
                console.log('Password toggle elements not found');
                return;
            }
            
            // Remove existing event listener to prevent duplicates
            toggleBtn.removeEventListener('click', handlePasswordToggle);
            
            // Add the event listener
            toggleBtn.addEventListener('click', handlePasswordToggle);
            
            function handlePasswordToggle() {
                const actualPassword = document.querySelector('#password').value;
                const isCurrentlyVisible = passwordDisplay.textContent !== '••••••••';
                
                if (isCurrentlyVisible) {
                    passwordDisplay.textContent = '••••••••';
                    toggleIcon.classList.remove('fa-eye-slash');
                    toggleIcon.classList.add('fa-eye');
                } else {
                    passwordDisplay.textContent = actualPassword;
                    toggleIcon.classList.remove('fa-eye');
                    toggleIcon.classList.add('fa-eye-slash');
                }
            }
        }

        formValidationNextButton.forEach(element => {
            element.addEventListener('click', function() {
                const currentStepIndex = stepper._currentIndex;

                // Validate step 1
                if (currentStepIndex === 0) {
                    if (validateStepOne()) {
                        stepper.next();
                    } 
                } else if (currentStepIndex === 1) {
                    if (validateStepTwo()) {
                        updateReviewStep();
                        stepper.next();
                    }
                } else if (currentStepIndex === 2) {
                    // Send email verification code
                }
            })
        });

        //  ID: integers only, max 6 digits
        const tupID = document.querySelector('#tup-id');
        if (tupID) {
            tupID.addEventListener('input', function (e) {
                let value = e.target.value;
                value = value.replace(/\D/g, '').slice(0, 6);
                if (e.target.value !== value) {
                    e.target.value = value;
                }
            });
        }

        formValidationBackButton.forEach(element => {
            element.addEventListener('click', function() {
                stepper.previous();
            })
        });

        formValidation.addEventListener('show.bs-stepper', function (event) {
            // Only handle visual step crossing, no validation here
            if (event.detail.from < event.detail.to) {
                formValidation.querySelectorAll('.step')[event.detail.from].classList.add('crossed');
            } else {
                formValidation.querySelectorAll('.step')[event.detail.to].classList.remove('crossed');
            }
            
            // Initialize OTP inputs when step 4 becomes active
            if (event.detail.to === 3) { // Step 4 (0-indexed)
                setTimeout(() => {
                    if (typeof initializeOTPInputs === 'function') {
                        initializeOTPInputs();
                    }
                }, 100);
            }
        })

        // Display email in modal when it opens
        document.getElementById('step3-next-btn').addEventListener('click', function() {
            const email = document.getElementById('email').value;
            document.getElementById('modal-email-display').textContent = email;
        });

        // Handle VERIFY button click
        document.querySelector('.btn-submit').addEventListener('click', function() {
            // Get the 6 digits inputs by user
            const inputs = document.querySelectorAll('.opt-input');
            let code = ''; // This is where we will store the 6 digits input

            // Combine all the input
            inputs.forEach(input => {
                code += input.value; // Concatenate
            });

            // Get the email for email verificatio query
            const email = document.querySelector('#email').value;

            // Disable button to avoid spam
            this.disabled = true;
            this.textContent = 'Verifying...'

            // Call the API to verify the code
            fetch('/email/verify-code', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRF-TOKEN': document.querySelector('meta[name="csrf-token"]').getAttribute('content')
                },
                body: JSON.stringify({
                    email: email,
                    code: code
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showModernAlert('Email verified successfully! Registration complete.', 'success');
                    // TODO: Redirect to login or complete registration
                 window.location.href = '/login';
                } else {
                    showModernAlert(data.message, 'error');
                    // Re-enable button
                    this.disabled = false;
                    this.textContent = 'VERIFY';
                    // Clear inputs
                    inputs.forEach(input => input.value = '');
                    inputs[0].focus();
                }
            })
            .catch(error => {
            console.error('Error:', error);
            showModernAlert('Error verifying code. Please try again.', 'error');
            // Re-enable button
            this.disabled = false;
            this.textContent = 'VERIFY';
            });
        });
    }

})