document.addEventListener('DOMContentLoaded', function () {

    /**
     * 
     *  Validation Horizontal  
     * 
     */

    var formValidation = document.querySelector('.stepper-form-validation-one');
    
    // Only initialize if the element exists
    if (formValidation) {
        var stepper = new Stepper(formValidation, {
            animation: true
        })
        var formValidationNextButton = formValidation.querySelectorAll('.btn-nxt');
        var formValidationBackButton = formValidation.querySelectorAll('.btn-back');
        var formValidationSubmit = formValidation.querySelector('.btn-submit');
        var stepperPanList = [].slice.call(formValidation.querySelectorAll('.content'))
        
        // Fix the selectors to match your HTML
        // var inputName = formValidation.querySelector('#validationStepform-first-name');
        var formEl = formValidation.querySelector('.bs-stepper-content form')

        function toggleLabelFeedback(inputEl, shouldShow) {
            if (!inputEl) return;
            const labelRow = inputEl.previousElementSibling;
            if (!labelRow) return;
            const feedbackEl = labelRow.querySelector('.invalid-feedback');
            if (!feedbackEl) return;
            feedbackEl.classList.toggle('d-block', shouldShow);
        }

        function setLabelFeedbackMessage(inputEl, message) {
            if (!inputEl) return;
            const labelRow = inputEl.previousElementSibling;
            if (!labelRow) return;
            const feedbackEl = labelRow.querySelector('.invalid-feedback');
            if (!feedbackEl) return;
            if (typeof message === 'string') {
                feedbackEl.textContent = message;
            }
        }

        function setFieldValid(inputEl) {
            if (!inputEl) return;
            inputEl.classList.remove('is-invalid');
            inputEl.classList.add('is-valid');
            toggleLabelFeedback(inputEl, false);
        }

        function setFieldInvalid(inputEl, message) {
            if (!inputEl) return;
            inputEl.classList.remove('is-valid');
            inputEl.classList.add('is-invalid');
            setLabelFeedbackMessage(inputEl, message);
            toggleLabelFeedback(inputEl, true);
        }

        function toggleFeedbackInContainer(containerEl, shouldShow) {
            if (!containerEl) return;
            const feedbackEl = containerEl.querySelector('.invalid-feedback');
            if (!feedbackEl) return;
            feedbackEl.classList.toggle('d-block', shouldShow);
        }

        function validateStepOne() {
            // Get all the input fields
            const currentStep = document.querySelector('#validationStep-one');
            const firstName = document.querySelector('#first-name');
            const middleName = document.querySelector('#middle-name');
            const lastName = document.querySelector('#last-name');
            const suffix = document.querySelector('#suffix');
            const tupID = document.querySelector('#tup-id');

            const stepOneValidation = {
                firstName: {
                    el: firstName,
                    required: true,
                    min: 3,
                    max: 50,
                    messages: {
                        required: 'First name is required.',
                        min: 'First name must be at least 3 characters.',
                        max: 'First name must be 50 characters or less.',
                    }
                },
                middleName: {
                    el: middleName,
                    required: true,
                    min: 3,
                    max: 50,
                    messages: {
                        required: 'Middle name is required.',
                        min: 'Middle name must be at least 3 characters.',
                        max: 'Middle name must be 50 characters or less.',
                    }
                },
                lastName: {
                    el: lastName,
                    required: true,
                    min: 3,
                    max: 50,
                    messages: {
                        required: 'Last name is required.',
                        min: 'Last name must be at least 3 characters.',
                        max: 'Last name must be 50 characters or less.',
                    }
                },
                suffix: {
                    el: suffix,
                    required: false,
                    max: 10,
                    messages: {
                        max: 'Suffix must be 10 characters or less.',
                    }
                },
                tupID: {
                    el: tupID,
                    required: true,
                    pattern: /^\d{6}$/,
                    messages: {
                        required: 'TUP ID is required.',
                        pattern: 'TUP ID must be exactly 6 digits.'
                    }
                }
            };

            let isValid = true;

            // Clear validation states
            currentStep.querySelectorAll('.form-control').forEach(input => {
                input.classList.remove('is-invalid', 'is-valid');
                toggleLabelFeedback(input, false);
            });

            Object.values(stepOneValidation).forEach(cfg => {
                const el = cfg.el;
                if (!el) {
                    isValid = false;
                    return;
                }

                const value = (el.value || '').trim();

                if (!cfg.required && value.length === 0) {
                    setFieldValid(el);
                    return;
                }

                if (cfg.required && value.length === 0) {
                    setFieldInvalid(el, cfg.messages.required);
                    isValid = false;
                    return;
                }

                if (typeof cfg.min === 'number' && value.length < cfg.min) {
                    setFieldInvalid(el, cfg.messages.min);
                    isValid = false;
                    return;
                }

                if (typeof cfg.max === 'number' && value.length > cfg.max) {
                    setFieldInvalid(el, cfg.messages.max);
                    isValid = false;
                    return;
                }

                if (cfg.pattern instanceof RegExp && !cfg.pattern.test(value)) {
                    setFieldInvalid(el, cfg.messages.pattern);
                    isValid = false;
                    return;
                }

                setFieldValid(el);
            });

            return isValid;
        }

        function validateStepTwo() {
            // Get all the input fields
            const currentStep = document.querySelector('#validationStep-two');
            const email = document.querySelector('#email');
            const password = document.querySelector('#password');
            const confirmPassword = document.querySelector('#confirm-password');
            const userType = document.querySelector('input[name="user-type"]:checked');
            const userTypeLabelRow = currentStep?.querySelector('label[for="user-type"]')?.parentElement;
            const department = document.querySelector('#department');

            const stepTwoValidation = {
                email: {
                    el: email,
                    required: true,
                    pattern: /^.+@tup\.edu\.ph$/i,
                    messages: {
                        required: 'Email is required.',
                        pattern: 'Enter a valid TUP email address.'
                    }
                },
                password: {
                    el: password,
                    required: true,
                    min: 8,
                    max: 128,
                    pattern: /^(?=.*[A-Za-z])(?=.*\d)[A-Za-z\d@$!%*?&]{8,}$/,
                    messages: {
                        required: 'Password is required.',
                        min: 'Password must be at least 8 characters.',
                        max: 'Password must be 128 characters or less.',
                        pattern: 'Password must contain at least one letter and one number.'
                    }
                },
                confirmPassword: {
                    el: confirmPassword,
                    required: true,
                    custom: () => {
                        const pwd = password?.value?.trim() || '';
                        const cpwd = confirmPassword?.value?.trim() || '';
                        return pwd === cpwd;
                    },
                    messages: {
                        required: 'Confirm password is required.',
                        custom: 'Passwords do not match.'
                    }
                },
                department: {
                    el: department,
                    required: true,
                    custom: () => {
                        return department && department.selectedIndex > 0;
                    },
                    messages: {
                        required: 'Please select.',
                        custom: 'Please select.'
                    }
                }
            };

            const userTypeConfig = {
                required: true,
                messages: {
                    required: 'Please choose your user type.'
                }
            };

            let isValid = true;

            // Clear validation states
            currentStep.querySelectorAll('.form-control, .form-select').forEach(input => {
                input.classList.remove('is-invalid', 'is-valid');
                toggleLabelFeedback(input, false);
            });

            toggleFeedbackInContainer(userTypeLabelRow, false);

            Object.values(stepTwoValidation).forEach(cfg => {
                const el = cfg.el;
                if (!el) {
                    isValid = false;
                    return;
                }

                const value = (el.value || '').trim();

                if (!cfg.required && value.length === 0) {
                    el.classList.remove('is-invalid', 'is-valid');
                    toggleLabelFeedback(el, false);
                    return;
                }

                if (cfg.required && value.length === 0) {
                    setFieldInvalid(el, cfg.messages.required);
                    isValid = false;
                    return;
                }

                if (typeof cfg.min === 'number' && value.length < cfg.min) {
                    setFieldInvalid(el, cfg.messages.min);
                    isValid = false;
                    return;
                }

                if (typeof cfg.max === 'number' && value.length > cfg.max) {
                    setFieldInvalid(el, cfg.messages.max);
                    isValid = false;
                    return;
                }

                if (cfg.pattern instanceof RegExp && !cfg.pattern.test(value)) {
                    setFieldInvalid(el, cfg.messages.pattern);
                    isValid = false;
                    return;
                }

                if (typeof cfg.custom === 'function' && !cfg.custom()) {
                    setFieldInvalid(el, cfg.messages.custom);
                    isValid = false;
                    return;
                }

                setFieldValid(el);
            });

            // User type (radio group)
            if (!userType) {
                toggleFeedbackInContainer(userTypeLabelRow, true);
                if (userTypeLabelRow) {
                    const feedbackEl = userTypeLabelRow.querySelector('.invalid-feedback');
                    if (feedbackEl) feedbackEl.textContent = userTypeConfig.messages.required;
                }
                isValid = false;
            }

            return isValid;
        }

        // Collect user inputs for review (step 3)
        function collectFormData() {
            return {
                firstName: document.querySelector('#first-name').value,
                middleName: document.querySelector('#middle-name').value,
                lastName: document.querySelector('#last-name').value,
                suffix: document.querySelector('#suffix').value || 'N/A',
                tupID: document.querySelector('#tup-id').value,
                email: document.querySelector('#email').value,
                password: '••••••••', // Masked for security
                userType: document.querySelector('input[name="user-type"]:checked')?.nextElementSibling?.textContent?.trim(),
                department: document.querySelector('#department').options[document.querySelector('#department').selectedIndex]?.text
            };
        }

        function updateReviewStep() {
            const data = collectFormData();
            
            // Update left column
            document.querySelector('#review-first-name').textContent = data.firstName;
            document.querySelector('#review-last-name').textContent = data.lastName;
            document.querySelector('#review-email').textContent = data.email;
            document.querySelector('#review-password').textContent = data.password;
            
            // Update right column  
            document.querySelector('#review-middle-name').textContent = data.middleName;
            document.querySelector('#review-suffix').textContent = data.suffix;
            document.querySelector('#review-tup-id').textContent = data.tupID;
            document.querySelector('#review-user-type').textContent = data.userType;
            
            // Update department row
            document.querySelector('#review-department').textContent = data.department;
            
            // Setup password toggle
            setupPasswordToggle();
        }

        function setupPasswordToggle() {
            const toggleBtn = document.getElementById('toggle-password-review');
            const toggleIcon = document.getElementById('password-toggle-icon');
            const passwordDisplay = document.getElementById('review-password');
            
            if (!toggleBtn || !toggleIcon || !passwordDisplay) {
                console.log('Password toggle elements not found');
                return;
            }
            
            // Remove existing event listener to prevent duplicates
            toggleBtn.removeEventListener('click', handlePasswordToggle);
            
            // Add the event listener
            toggleBtn.addEventListener('click', handlePasswordToggle);
            
            function handlePasswordToggle() {
                const actualPassword = document.querySelector('#password').value;
                const isCurrentlyVisible = passwordDisplay.textContent !== '••••••••';
                
                if (isCurrentlyVisible) {
                    passwordDisplay.textContent = '••••••••';
                    toggleIcon.classList.remove('fa-eye-slash');
                    toggleIcon.classList.add('fa-eye');
                } else {
                    passwordDisplay.textContent = actualPassword;
                    toggleIcon.classList.remove('fa-eye');
                    toggleIcon.classList.add('fa-eye-slash');
                }
            }
        }

        formValidationNextButton.forEach(element => {
            element.addEventListener('click', function() {
                const currentStepIndex = stepper._currentIndex;

                // Validate step 1
                if (currentStepIndex === 0) {
                    if (validateStepOne()) {
                        stepper.next();
                    } 
                } else if (currentStepIndex === 1) {
                    if (validateStepTwo()) {
                        updateReviewStep();
                        stepper.next();
                    }
                } else if (currentStepIndex === 2) {
                    // Send email verification code
                }
            })
        });

        //  ID: integers only, max 6 digits
        const tupID = document.querySelector('#tup-id');
        if (tupID) {
            tupID.addEventListener('input', function (e) {
                let value = e.target.value;
                value = value.replace(/\D/g, '').slice(0, 6);
                if (e.target.value !== value) {
                    e.target.value = value;
                }
            });
        }

        formValidationBackButton.forEach(element => {
            element.addEventListener('click', function() {
                stepper.previous();
            })
        });

        formValidation.addEventListener('show.bs-stepper', function (event) {
            // Only handle visual step crossing, no validation here
            if (event.detail.from < event.detail.to) {
                formValidation.querySelectorAll('.step')[event.detail.from].classList.add('crossed');
            } else {
                formValidation.querySelectorAll('.step')[event.detail.to].classList.remove('crossed');
            }
        })

        formValidationSubmit.addEventListener('click', function() {
            formEl.classList.remove('was-validated')

            if (
                (!inputAddress.value.length)
                ||
                (!inputCity.value.length)
                ||
                (!inputState.value.length)
                ||
                (!inputZip.value.length)
                ||
                (!gridCheck.checked)
            ) {
                formEl.classList.add('was-validated')
            }
        })
    }

})